from simulation.Node import Node
from simulation.Flow import Flow
from simulation.Frame import Frame
from simulation.Core import SimulationEnvironment
from simpy import Event, Process, Interrupt
from collections import deque


class Talker(Node):
    def __init__(self, env: SimulationEnvironment, address: str, monitor: bool = False):
        super(Talker, self).__init__(env, address, monitor)
        self.queue = deque()
        self.sleeping: bool = False
        self.sleep_event: Event = env.event()
        self.send_process: Process = env.process(self.process_send_frame())

        self.data = list()

    def get_data(self) -> (list, str):
        if self.monitor:
            result = list()
            for frame in self.data:
                if frame.delays.__len__() == 0:
                    frame_dict = {"frame_id": frame.id, "flow_id": frame.flow.id,
                                  "frame_len": frame.__len__(), "frame_priority": frame.priority,
                                  "sender": self.address, "receiver": "",
                                  "start_time": frame.start_time, "arrival_time": "", "delay": ""}
                    result.append(frame_dict)
                else:
                    for receiver_address, delay in frame.delays.items():
                        frame_dict = {"frame_id": frame.id, "flow_id": frame.flow.id,
                                      "frame_len": frame.__len__(), "frame_priority": frame.priority,
                                      "sender": self.address, "receiver": receiver_address,
                                      "start_time": frame.start_time, "arrival_time": frame.start_time + delay,
                                      "delay": delay}
                        result.append(frame_dict)
            return result, "talker"
        else:
            return None, None

    def add_flow(self, flow: Flow, priority: int, payload_generator=None):
        """
        Adds a flow to this Talker. This will create a process which creates frames this talker will send
        :param flow: flow for which frames are generated, this also provides the leaky_rate for the frame generation
        :param priority: priority of the frames
        :param payload_generator: payload of the frames
        """
        self.env.process(self.process_flow_create_frame(flow, priority, payload_generator))

    def process_send_frame(self):
        """
        process which sends frames generated by process_flow_create_frame
        """
        while True:
            if self.queue.__len__() > 0:
                frame = self.queue.popleft()
                if self.monitor:
                    self.data.append(frame)
                receiver_address = frame.flow.path[self.address][0]
                sending_object = self.send_frame(receiver_address, frame)
                yield sending_object.process
                self.env.sim_print("send frame")
            else:
                self.sleeping = True
                try:
                    yield self.sleep_event
                except Interrupt:
                    self.sleeping = False

    def process_flow_create_frame(self, flow: Flow, priority: int, payload_generator):
        """
        process which creates frames in a leaky bucket pattern with leaky_rate from the flow
        :param flow:
        :param priority:
        :param payload_generator:
        """
        while True:
            # frame = Frame(0, flow, priority, payload_generator.__next__())
            frame = Frame(self.env.frame_id(), flow, 1500, priority)
            self.queue.append(frame)
            if self.sleeping:
                self.sleeping = False
                self.send_process.interrupt("new frame")
            yield self.env.timeout(frame.__len__() * 8 / flow.leaky_rate)
